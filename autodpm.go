package main

import (
	"errors"
	"fmt"
	"html"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/jmoiron/sqlx"
)

// Map to match when2works mapping
var days = map[string]string{
	"Monday":    "0",
	"Tuesday":   "1",
	"Wednesday": "2",
	"Thursday":  "3",
	"Friday":    "4",
	"Saturday":  "5",
	"Sunday":    "6",
}

// Create a slice of DPMRes and return them
// Function handling the rendering of the autogen page will call this function, get the slice of dpms
// and pass it into the template
// The template will loop over the slice and print out the autogenerated stuff
// There will be a submit button to submit all the autogenerated dpms
// Maybe have a server wide variable, or a file that the server reads from, that keeps track of the last time some one auto generated DPMs

// AutoGen parses the when2work page for the current date, of the server (EST), and generates a slice of DPMDriver's
// which are a simplified version of a full DPM
func autoGen(db *sqlx.DB) ([]dpmDriver, error) {
	// Check to make sure that no dpms have be autosubmitted for today
	err := checkLastSubmission(db)
	if err != nil {
		return nil, err
	}
	dpms := make([]dpmDriver, 0)
	// Post Request to signin
	// Can get SID from this line
	// <a href="#" onclick="window.open('/cgi-bin/w2wG3.dll/mgrcontact.htm?SID=42041057341E7',
	response, err := http.PostForm(
		"https://whentowork.com/cgi-bin/w2w.dll/login",
		url.Values{
			"Launch":          {""},
			"LaunchParams":    {""},
			"Password1":       {os.Getenv("W2W_PASS")},
			"Submit1":         {"Please Wait..."},
			"UserId1":         {os.Getenv("W2W_USER")},
			"captca_required": {"false"},
			"name":            {"signin"},
		},
	)
	if err != nil {
		fmt.Println(err)
		return nil, errors.New("failed to create post request")
	}
	defer response.Body.Close()

	// Read post response
	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		return nil, errors.New("failed to read response from post to when2work")
	}

	// Find SID from post request
	re := regexp.MustCompile(`SID=\w+`)
	sid := string(re.Find(body))
	if sid == "" {
		return nil, errors.New("failed to get SID from when2work response")
	}

	// The 'w2wG4' part of the reference url below may change, slightly, between requests
	// This ensures that the correct value is included in the url to avoid errors
	re = regexp.MustCompile(`data-w2w="\/cgi-bin\/w2wG.?\.dll\/"`)
	dllPath := string(re.Find(body))
	if dllPath == "" {
		return nil, errors.New("failed to get dll path from response")
	}

	dllPath = strings.Trim(strings.Replace(dllPath, "data-w2w=\"", "", 1), "\"")

	// Get day of week, so that I am parsing the correct date
	weekday := days[string(time.Now().Weekday())]
	// Reference URL
	// https://www7.whentowork.com/cgi-bin/w2wG4.dll/mgrschedule?SID=42041057341E7&lmi=1&view=Pos
	response, err = http.Get(fmt.Sprintf("https://www7.whentowork.com%smgrschedule?%s&lmi=1&view=Pos&Day=%s", dllPath, sid, weekday))
	if err != nil {
		fmt.Println(err)
		return nil, errors.New("failed to pull up schedules page")
	}
	defer response.Body.Close()

	// Read from response body
	body, err = ioutil.ReadAll(response.Body)
	if err != nil {
		return nil, errors.New("failed to read response from when2work")
	}

	// fmt.Println("*****************************")
	// fmt.Println(string(body))

	// Can't escape backticks in backticks, so I need to append this to regex so that it catches backticks
	tick := "`"
	// This gets shifts via regex
	// either swl("952294753",2,"#000000","Brian Newman","959635624","07:00 - 14:20","   7.33 hours","OFF");
	// or ewl("959635634",2,"#000000","17:20 - 01:00","   7.67 hours","JPA"); if the shift is unassigned]
	re = regexp.MustCompile(`\wwl\("\d+",\d,"#\w+","[\w\d -:,~><^?@=|\\\[\]{}` + tick + `]+;`)
	// fmt.Println(string(body))
	shifts := re.FindAllString(string(body), -1)
	if shifts == nil {
		return nil, errors.New("failed to parse shifts")
	}

	// This gets the block numbers/shift and the respective number of shifts for that block
	// This is the format sh(2,"[01]","3 shifts - 18.00 hours");
	// But only matching sh(2,"[01]","3
	// The [chararcters] may replaced with something else like Charter
	re = regexp.MustCompile(`sh\(\d+,"[\[\w+\]a-zA-Z ()]+","\d+`)
	blocks := re.FindAllString(string(body), -1)
	if blocks == nil {
		return nil, errors.New("failed to parse blocks")
	}

	// Keep track of position in shifts slice
	var position int
	// For each block, get the number of shifts under it, and loop that many positions in shifts array
	for _, block := range blocks {
		// If block is not surrounded in []'s, get the number of shifts under it (ignore it)
		// Add this number to position variable so that those shifts are passed over in slice iteration below
		if !strings.Contains(block, "[") || !strings.Contains(block, "]") {
			sliced := strings.Split(block, "\"")
			num := sliced[len(sliced)-1]
			incrementAmount, err := strconv.Atoi(num)
			if err != nil {
				fmt.Println(err)
				return nil, err
			}
			position += incrementAmount
			fmt.Println("Skipping non block type shift")
			continue
		}
		// Get block, is in this format [BLOCK]
		re = regexp.MustCompile(`\[\w+\]`)
		// Turn block into string
		blockNum := string(re.Find([]byte(block)))
		// Replace surrounding []'s
		blockNum = blockNum[1 : len(blockNum)-1]
		// Get last number, aka number of shifts of this block
		// Is in this format "number
		re = regexp.MustCompile(`"\d+`)
		// Get value from find, []byte, turn it into a string, then remove the beginning "
		num, err := strconv.Atoi(string(re.Find([]byte(block))[1:]))
		if err != nil {
			fmt.Println(err)
			break
		}
		// Iterate a num number of times in shifts slice
		// Keeping track of indexing allows me to associate drivers to their blocks
		f := position + num
		for position < f {
			if position >= len(shifts) {
				return nil, errors.New("failed to parse all blocks. Please make sure that all blocks contain a value for location")
			}
			s := shifts[position]
			fmt.Println(s, blockNum)
			// If shift is unassigned skip
			// Only matching unassigned shifts because the number of shifts under a block include them
			if s[0] == 'e' {
				position++
				continue
			}
			// swl("952294753",2,"#000000","Brian Newman","959635624","07:00 - 14:20","   7.33 hours","OFF");
			info := strings.Split(s, ",")
			// Get hex color
			color := strings.Replace(strings.Trim(info[2], "\""), "#", "", 1)
			// Get driver name
			name := strings.Trim(info[3], "\"")
			// Get first and last name
			ns := strings.Split(name, " ")
			// Sanitize first name
			first := bm.Sanitize(ns[0])
			last := ""
			// Join indexes after 0 into last name string and sanitize
			if len(ns) > 1 {
				ns = append(ns[:0], ns[1:]...)
				last = bm.Sanitize(strings.Join(ns, " "))
			}
			// Get start and end time
			times := strings.Trim(info[5], "\"")
			// If time does not match export format, skip
			if len(times) != 13 {
				fmt.Println("Error getting time, skipping")
				position++
				continue
			}
			startTime := times[0:5]
			endTime := times[8:]
			// Get location
			// If location is missing, skip
			locationNotes := strings.Trim(info[7], "\"")
			if len(strings.TrimSpace(locationNotes)) < 2 {
				fmt.Println("Line has no location, skipping")
				position++
				continue
			}
			var location string
			if len(locationNotes) == 2 || len(locationNotes) == 3 {
				location = strings.TrimSpace(locationNotes[:])
			} else {
				location = strings.TrimSpace(locationNotes[0:3])
			}
			if strings.Contains(location, "-") {
				location = location[0:2]
			}
			// Make sure location is capitalized
			location = strings.ToUpper(location)
			location = strings.Replace(location, "\"", "", -1)
			// Get current date
			date := time.Now().Format("2006-1-02")
			// If color does not start with f, ignore it, only looking for red, FF0000, and gold, ffcc00
			if color[1] == 'f' || color[1] == 'F' {
				fmt.Println("**************************************")
				fmt.Println(first, last, location, len(location))
				fmt.Println("**************************************")
				// Remove '3' and convert color to lowercase
				color = strings.ToLower(color)
				d := dpmDriver{
					FirstName: html.UnescapeString(first),
					LastName:  html.UnescapeString(last),
					Block:     bm.Sanitize(blockNum),
					Location:  bm.Sanitize(location),
					Date:      bm.Sanitize(date),
					StartTime: bm.Sanitize(startTime),
					EndTime:   bm.Sanitize(endTime),
				}
				// If color is gold, Good dpm
				if color == "ffcc00" {
					d.DPMType = "Type G: Picked Up Block (+1 Point)"
					d.Points = "+1"
					d.Notes = "Thanks!"
					dpms = append(dpms, d)
					// If color is red, DNS dpm
				} else if color == "ff0000" {
					d.DPMType = "Type D: DNS/Did Not Show (-10 Points)"
					d.Points = "-10"
					// Get index of DNS and get rid of everything before it as well as "DNS"
					index := strings.Index(s, "DNS")
					// If DNS is not found, don't worry about trying to get notes for it
					if index != -1 {
						notes := s[index+3:]
						notes = strings.Replace(notes, ")", "", -1)
						notes = strings.Replace(notes, "(", "", -1)
						notes = strings.Replace(notes, `"`, "", -1)
						notes = strings.TrimSpace(strings.Trim(notes, ";"))
						if len(notes) != 0 {
							fmt.Println(notes)
							d.Notes = notes
						}
					}
					dpms = append(dpms, d)
				}
			}
			// Be sure to increment position
			position++
		}
	}
	return dpms, nil
}

// AutoSubmit takes in a slice of driver dpms and turns them into full dpms and submits them
// return an error if applicable otherwise returns nil
func autoSubmit(db *sqlx.DB, dpms []dpmDriver, sender int16) error {
	var (
		id     int16
		points int16
	)
	// Check to make sure that no dpms have been autosubmitted for today
	err := checkLastSubmission(db)
	if err != nil {
		return err
	}

	// Prepare select statement for repeated use
	stmt, err := db.Prepare(`SELECT id FROM users WHERE firstname=$1 AND lastname=$2 LIMIT 1`)
	if err != nil {
		fmt.Println("Problem with preparing SELECT statement.\n", err)
		return err
	}
	// Make sure to close stmt
	defer stmt.Close()
	// Query to create a new dpm into the database
	dpmIn := `INSERT INTO dpms (createid, userid, firstname, lastname, block, date, starttime, endtime, dpmtype, points, notes, created, location, approved) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, false)`
	// Iterate through the slice of dpms
	for _, d := range dpms {
		d.FirstName = strings.Replace(d.FirstName, "'", "’", -1)
		d.LastName = strings.Replace(d.LastName, "'", "’", -1)
		// Get id, and fulltimer bool based on first and last name
		err = stmt.QueryRow(d.FirstName, d.LastName).Scan(&id)
		// If error is not nil, assume it is because user not in db, not fatal, keep going
		if err != nil {
			fmt.Println("Failed to find", d.FirstName, d.LastName, "in the DB")
			fmt.Println(err)
			continue
		}
		// Get current time’
		created := time.Now().Format("2006-1-02 15:04:05")
		if d.DPMType == "Type G: Picked Up Block (+1 Point)" {
			// Set points
			points = 1
			// Execute query with values
			_, err := db.Exec(dpmIn, sender, id, d.FirstName, d.LastName, d.Block, d.Date, d.StartTime, d.EndTime, d.DPMType, points, d.Notes, created, d.Location)
			// If error, this is fatal so print and exit function
			if err != nil {
				fmt.Println("Autogen input failure, +1")
				fmt.Println(err)
				return err
			}
			// Create negative dpm
		} else if d.DPMType == "Type D: DNS/Did Not Show (-10 Points)" {
			// Set points
			points = -10
			// Execute query
			_, err := db.Exec(dpmIn, sender, id, d.FirstName, d.LastName, d.Block, d.Date, d.StartTime, d.EndTime, d.DPMType, points, d.Notes, created, d.Location)
			// If error, fatal, exit function
			if err != nil {
				fmt.Println("Autogen input failure, -10")
				fmt.Println(err)
				return err
			}
		}
	}
	// If function has made it this far with no errors, update submission time
	err = updateSubmitTime(db)
	if err != nil {
		return err
	}
	return nil
}

// checkLastSubmission checks text file to see when the last time autogen was called
// Only allows you autosubmit the dpms once a day
func checkLastSubmission(db *sqlx.DB) error {
	var dateSubmitted string
	// language=sql
	err := db.QueryRow(`select * from auto_submissions where date_submitted = DATE(now()) LIMIT 1`).Scan(&dateSubmitted)
	if err != nil {
		return errors.New("failed to check last submission")
	}

	if len(dateSubmitted) > 0 {
		return errors.New("autosubmit has already been called for today")
	}
	return nil
}

func updateSubmitTime(db *sqlx.DB) error {
	// language=sql
	_, err := db.Exec(`UPDATE auto_submissions SET date_submitted=NOW()`)
	if err != nil {
		return errors.New("failed to update submission time, DPMs still submitted")
	}
	return nil
}
