package com.tunjicus.utsdpm.services

import com.tunjicus.utsdpm.BaseIntegrationTest
import com.tunjicus.utsdpm.entities.*
import com.tunjicus.utsdpm.enums.RoleName
import com.tunjicus.utsdpm.models.Shift
import com.tunjicus.utsdpm.repositories.AutoSubmissionRepository
import jakarta.transaction.Transactional
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Test
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.`when`
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.test.context.bean.override.mockito.MockitoBean
import org.springframework.test.context.bean.override.mockito.MockitoSpyBean

class AutogenServiceTest() : BaseIntegrationTest() {
  @Autowired private lateinit var autoSubmissionRepository: AutoSubmissionRepository

  @MockitoBean private lateinit var authService: AuthService
  @MockitoSpyBean private lateinit var autogenService: AutogenService

  companion object {
    private val LOGGER = LoggerFactory.getLogger(AutogenServiceTest::class.java)
  }

  @AfterEach
  @Transactional
  fun cleanUp() {
    entityManager.flush()
    entityManager.clear()
    userDpmRepository.deleteAll()
    dpmRepository.deleteAll()
    dpmGroupRepository.deleteAll()
    dpmRepository.deleteAll()
    userRepository.deleteAll()
    w2wColorRepository.deleteAll()
    autoSubmissionRepository.deleteAll()
  }

  @Test
  @Transactional
  fun `should only get active colors associated to active dpms`() {
    val activeColor1 = createColor("Active Color 1", "1")
    val activeColor2 = createColor("Active Color 2", "2")
    val inactiveColor1 = createColor("Inactive Color 1", "3", false)
    val inactiveColor2 = createColor("Inactive Color 2", "4", false)

    val commonGroup = createGroup("Common Group")
    val activeDpm1 = createDpm("Active DPM 1", commonGroup, activeColor1)
    val activeDpm2 = createDpm("Active DPM 2", commonGroup, activeColor2)
    val inactiveDpm1 = createDpm("Inactive DPM 1", commonGroup, inactiveColor1)
    val inactiveDpm2 = createDpm("Inactive DPM 2", commonGroup, inactiveColor2)

    entityManager.flush()
    entityManager.clear()
    val colorsWithDpms = w2wColorRepository.findAllActiveWithDpms()

    LOGGER.info("Found ${colorsWithDpms.size} active colors with dpms")
    colorsWithDpms.forEach { LOGGER.info(it.toString()) }

    assert(colorsWithDpms.size == 2) { "There should be 2 active colors" }
    assert(colorsWithDpms.contains(activeColor1)) { "Color list should contain Active Color 1" }
    assert(colorsWithDpms.contains(activeColor2)) { "Color list should contain Active Color 2" }
    assert(!colorsWithDpms.contains(inactiveColor1)) {
      "Color list should not contain Inactive Color 1"
    }
    assert(!colorsWithDpms.contains(inactiveColor2)) {
      "Color list should not contain Inactive Color 2"
    }
    assert(colorsWithDpms.all { it.active }) { "All colors should be active" }
    assert(colorsWithDpms.all { it.dpms?.isNotEmpty() == true }) {
      "All colors should be associated with at least 1 dpm"
    }
    assert(colorsWithDpms.any { it.dpms?.contains(activeDpm1) == true }) {
      "One of the colors should be associated with Active DPM 1"
    }
    assert(colorsWithDpms.any { it.dpms?.contains(activeDpm2) == true }) {
      "One of the colors should be associated with Active DPM 2"
    }
    assert(colorsWithDpms.any { it.dpms?.contains(inactiveDpm1) == false }) {
      "None of the colors should be associated with Inactive DPM 1"
    }
    assert(colorsWithDpms.any { it.dpms?.contains(inactiveDpm2) == false }) {
      "None of the colors should be associated with Inactive DPM 2"
    }
  }

  @Test
  @Transactional
  fun `should see autogenerated dpms in the database`() {
    val adminRole = roleRepository.save(Role().apply { roleName = RoleName.ADMIN })

    val adminUser =
        User().apply {
          username = "admin@user.com"
          firstname = "Admin"
          lastname = "User"
          fullTime = true
          password = "<PASSWORD>"
          role = adminRole
        }
    userRepository.save(adminUser)

    val driver =
        User().apply {
          username = "driver@test.com"
          firstname = "Test"
          lastname = "Driver"
          points = 0
          fullTime = true
          password = "<PASSWORD>"
          manager = adminUser
        }
    userRepository.save(driver)

    val dpmGroup = createGroup("Test Group")

    val activeColor1 = createColor("Active Color 1", "1")
    val activeColor2 = createColor("Active Color 2", "2")
    val dpmEntity1 = createDpm("Test DPM 1", dpmGroup, activeColor1)
    val dpmEntity2 = createDpm("Test DPM 2", dpmGroup, activeColor2)

    `when`(authService.getCurrentUser()).thenReturn(adminUser)
    // Create some mock shifts that getAssignedShifts would return
    val mockShift1 = createShift(activeColor1.colorCode, driver.firstname!!, driver.lastname!!)
    val mockShift2 = createShift(activeColor2.colorCode, driver.firstname!!, driver.lastname!!)
    val mockShift3UntrackedColor =
        createShift(
            "0",
            driver.firstname!!,
            driver.lastname!!) // Will be filtered by `it.colorId in dpmColorMap`
    val mockShift4NotPublished =
        createShift(activeColor1.colorCode, driver.firstname!!, driver.lastname!!)
            .copy(published = "N") // will be filtered by published status
    val mockShift5NoBracket =
        createShift(activeColor1.colorCode, driver.firstname!!, driver.lastname!!)
            .copy(block = "EB") // will be filtered by block

    val mockShifts =
        listOf(
            mockShift1,
            mockShift2,
            mockShift3UntrackedColor,
            mockShift4NotPublished,
            mockShift5NoBracket)
    doReturn(mockShifts).`when`(autogenService).getAssignedShifts()

    entityManager.flush()
    entityManager.clear()
    autogenService.autoSubmit()

    entityManager.flush()
    entityManager.clear()

    val userDpms = userDpmRepository.findAll()
    assert(userDpms.size == 2) { "There should be 2 dpms in the database. Found ${userDpms.size}" }
    val createdDpmTypes = userDpms.mapNotNull { it.dpmType }

    assert(createdDpmTypes.any { it.id == dpmEntity1.id }) {
      "UserDPM list should contain one for DPM ${dpmEntity1.dpmName}"
    }
    assert(createdDpmTypes.any { it.id == dpmEntity2.id }) {
      "UserDPM list should contain one for DPM ${dpmEntity2.dpmName}"
    }

    val actualDpm1Points = userDpms.find { it.dpmType == dpmEntity1 }?.points ?: Integer.MIN_VALUE
    assert(actualDpm1Points == dpmEntity1.points) {
      "Test DPM 1 should have the same points as the original DPM. Expected: ${dpmEntity1.points}, Actual: $actualDpm1Points"
    }

    val actualDpm2Points = userDpms.find { it.dpmType == dpmEntity2 }?.points ?: Integer.MIN_VALUE
    assert(actualDpm2Points == dpmEntity2.points) {
      "Test DPM 2 should have the same points as the original DPM. Expected: ${dpmEntity2.points}, Actual: $actualDpm2Points"
    }
  }

  @Transactional
  fun createDpm(name: String, group: DpmGroup, color: W2WColor? = null): Dpm {
    return dpmRepository.saveAndFlush(
        Dpm().apply {
          this.dpmName = name
          this.points = (-10..10).random()
          this.dpmGroup = group
          this.w2wColor = color
        })
  }

  @Transactional
  fun createColor(name: String, code: String, active: Boolean = true): W2WColor {
    return w2wColorRepository.saveAndFlush(
        W2WColor().apply {
          this.colorName = name
          this.colorCode = code
          this.active = active
          this.hexCode = "#000000"
        })
  }

  private fun createShift(
      colorId: String,
      firstName: String,
      lastName: String,
      description: String = "",
      block: String = "[EB]",
      published: String = "Y"
  ): Shift {
    return Shift(
        published = published,
        firstName = firstName,
        lastName = lastName,
        startDate = "5/24/2025",
        endDate = "5/24/2025",
        startTime = "10:00am",
        endTime = "12:00pm",
        description = description,
        colorId = colorId,
        block = block)
  }

  @Test
  @Transactional
  fun `should return empty list when no shifts match color map`() {
    val activeColor = createColor("Active Color", "1")
    val group = createGroup("Test Group")
    createDpm("Test DPM", group, activeColor)

    // Create shift with non-matching color
    val mockShift = createShift("999", "Test", "User")
    doReturn(listOf(mockShift)).`when`(autogenService).getAssignedShifts()

    entityManager.flush()
    entityManager.clear()

    val result = autogenService.autogenDtos()
    assertThat(result.dpms).isEmpty()
  }

  @Test
  @Transactional
  fun `should return empty list when all shifts have invalid block format`() {
    val activeColor = createColor("Active Color", "1")
    val group = createGroup("Test Group")
    createDpm("Test DPM", group, activeColor)

    // Create shift without bracket in block
    val mockShift = createShift(activeColor.colorCode, "Test", "User", block = "EB")
    doReturn(listOf(mockShift)).`when`(autogenService).getAssignedShifts()

    entityManager.flush()
    entityManager.clear()

    val result = autogenService.autogenDtos()
    assertThat(result.dpms).isEmpty()
  }

  @Test
  @Transactional
  fun `should filter out unpublished shifts`() {
    val activeColor = createColor("Active Color", "1")
    val group = createGroup("Test Group")
    createDpm("Test DPM", group, activeColor)

    val publishedShift = createShift(activeColor.colorCode, "Test", "User", published = "Y")
    val unpublishedShift = createShift(activeColor.colorCode, "Test2", "User2", published = "N")
    doReturn(listOf(publishedShift, unpublishedShift)).`when`(autogenService).getAssignedShifts()

    entityManager.flush()
    entityManager.clear()

    val result = autogenService.autogenDtos()
    assertThat(result.dpms).hasSize(1)
    assertThat(result.dpms[0].name).isEqualTo("Test User")
  }

  @Test
  @Transactional
  fun `should handle empty shift list`() {
    val activeColor = createColor("Active Color", "1")
    val group = createGroup("Test Group")
    createDpm("Test DPM", group, activeColor)

    doReturn(emptyList<Shift>()).`when`(autogenService).getAssignedShifts()

    entityManager.flush()
    entityManager.clear()

    val result = autogenService.autogenDtos()
    assertThat(result.dpms).isEmpty()
    assertThat(result.submitted).isNull()
  }

  @Test
  @Transactional
  fun `should process shifts with description containing notes`() {
    val adminRole = roleRepository.save(Role().apply { roleName = RoleName.ADMIN })
    val adminUser =
        userRepository.save(
            User().apply {
              username = "admin@test.com"
              firstname = "Admin"
              lastname = "User"
              fullTime = true
              password = "<PASSWORD>"
              role = adminRole
            })

    val driver =
        userRepository.save(
            User().apply {
              username = "driver@test.com"
              firstname = "John"
              lastname = "Doe"
              points = 0
              fullTime = true
              password = "<PASSWORD>"
              manager = adminUser
            })

    val group = createGroup("Test Group")
    val activeColor = createColor("Active Color", "1")
    createDpm("Test DPM", group, activeColor)

    `when`(authService.getCurrentUser()).thenReturn(adminUser)

    val shiftWithNotes = createShift(
        activeColor.colorCode,
        driver.firstname!!,
        driver.lastname!!,
        description = "[1] {Driver arrived late}"
    )
    doReturn(listOf(shiftWithNotes)).`when`(autogenService).getAssignedShifts()

    entityManager.flush()
    entityManager.clear()

    autogenService.autoSubmit()

    entityManager.flush()
    entityManager.clear()

    val userDpms = userDpmRepository.findAll()
    assertThat(userDpms).hasSize(1)
    assertThat(userDpms[0].location).isEqualTo("OTR")
    assertThat(userDpms[0].notes).isEqualTo("Driver arrived late")
  }

  @Test
  @Transactional
  fun `should sort shifts by block number`() {
    val activeColor = createColor("Active Color", "1")
    val group = createGroup("Test Group")
    createDpm("Test DPM", group, activeColor)

    val shift1 = createShift(activeColor.colorCode, "User", "One", block = "[EB3]")
    val shift2 = createShift(activeColor.colorCode, "User", "Two", block = "[EB1]")
    val shift3 = createShift(activeColor.colorCode, "User", "Three", block = "[EB2]")
    doReturn(listOf(shift1, shift2, shift3)).`when`(autogenService).getAssignedShifts()

    entityManager.flush()
    entityManager.clear()

    val result = autogenService.autogenDtos()
    assertThat(result.dpms).hasSize(3)
    // Should be sorted by block number
    assertThat(result.dpms[0].block).isEqualTo("[EB1]")
    assertThat(result.dpms[1].block).isEqualTo("[EB2]")
    assertThat(result.dpms[2].block).isEqualTo("[EB3]")
  }

  @Test
  @Transactional
  fun `should indicate positive flag for positive and negative point DPMs`() {
    val positiveColor = createColor("Positive Color", "1")
    val negativeColor = createColor("Negative Color", "2")
    val group = createGroup("Test Group")
    createDpmWithPoints("Positive DPM", group, 5, positiveColor)
    createDpmWithPoints("Negative DPM", group, -5, negativeColor)

    val positiveShift = createShift(positiveColor.colorCode, "Positive", "User", block = "[EB1]")
    val negativeShift = createShift(negativeColor.colorCode, "Negative", "User", block = "[EB2]")
    doReturn(listOf(positiveShift, negativeShift)).`when`(autogenService).getAssignedShifts()

    entityManager.flush()
    entityManager.clear()

    val result = autogenService.autogenDtos()
    assertThat(result.dpms).hasSize(2)

    val positiveDpm = result.dpms.find { it.type == "Positive DPM" }
    val negativeDpm = result.dpms.find { it.type == "Negative DPM" }

    assertThat(positiveDpm).isNotNull
    assertThat(positiveDpm!!.positive).isTrue()

    assertThat(negativeDpm).isNotNull
    assertThat(negativeDpm!!.positive).isFalse()
  }

  @Transactional
  fun createDpmWithPoints(name: String, group: DpmGroup, points: Int, color: W2WColor? = null): Dpm {
    return dpmRepository.saveAndFlush(
        Dpm().apply {
          this.dpmName = name
          this.points = points
          this.dpmGroup = group
          this.w2wColor = color
        })
  }
}
