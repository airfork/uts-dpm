package com.tunjicus.utsdpm.services

import com.tunjicus.utsdpm.BaseIntegrationTest
import com.tunjicus.utsdpm.entities.*
import com.tunjicus.utsdpm.enums.RoleName
import com.tunjicus.utsdpm.models.Shift
import com.tunjicus.utsdpm.repositories.AutoSubmissionRepository
import jakarta.transaction.Transactional
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Test
import org.mockito.Mockito.doReturn
import org.mockito.Mockito.`when`
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.test.context.bean.override.mockito.MockitoBean
import org.springframework.test.context.bean.override.mockito.MockitoSpyBean

class AutogenServiceTest() : BaseIntegrationTest() {
  @Autowired private lateinit var autoSubmissionRepository: AutoSubmissionRepository

  @MockitoBean private lateinit var authService: AuthService
  @MockitoSpyBean private lateinit var autogenService: AutogenService

  companion object {
    private val LOGGER = LoggerFactory.getLogger(AutogenServiceTest::class.java)
  }

  @AfterEach
  @Transactional
  fun cleanUp() {
    entityManager.flush()
    entityManager.clear()
    userDpmRepository.deleteAll()
    dpmRepository.deleteAll()
    dpmGroupRepository.deleteAll()
    dpmRepository.deleteAll()
    userRepository.deleteAll()
    w2wColorRepository.deleteAll()
    autoSubmissionRepository.deleteAll()
  }

  @Test
  @Transactional
  fun `should only get active colors associated to active dpms`() {
    val activeColor1 = createColor("Active Color 1", "1")
    val activeColor2 = createColor("Active Color 2", "2")
    val inactiveColor1 = createColor("Inactive Color 1", "3", false)
    val inactiveColor2 = createColor("Inactive Color 2", "4", false)

    val commonGroup = createGroup("Common Group")
    val activeDpm1 = createDpm("Active DPM 1", commonGroup, activeColor1)
    val activeDpm2 = createDpm("Active DPM 2", commonGroup, activeColor2)
    val inactiveDpm1 = createDpm("Inactive DPM 1", commonGroup, inactiveColor1)
    val inactiveDpm2 = createDpm("Inactive DPM 2", commonGroup, inactiveColor2)

    entityManager.flush()
    entityManager.clear()
    val colorsWithDpms = w2wColorRepository.findAllActiveWithDpms()

    LOGGER.info("Found ${colorsWithDpms.size} active colors with dpms")
    colorsWithDpms.forEach { LOGGER.info(it.toString()) }

    assert(colorsWithDpms.size == 2) { "There should be 2 active colors" }
    assert(colorsWithDpms.contains(activeColor1)) { "Color list should contain Active Color 1" }
    assert(colorsWithDpms.contains(activeColor2)) { "Color list should contain Active Color 2" }
    assert(!colorsWithDpms.contains(inactiveColor1)) {
      "Color list should not contain Inactive Color 1"
    }
    assert(!colorsWithDpms.contains(inactiveColor2)) {
      "Color list should not contain Inactive Color 2"
    }
    assert(colorsWithDpms.all { it.active }) { "All colors should be active" }
    assert(colorsWithDpms.all { it.dpms?.isNotEmpty() == true }) {
      "All colors should be associated with at least 1 dpm"
    }
    assert(colorsWithDpms.any { it.dpms?.contains(activeDpm1) == true }) {
      "One of the colors should be associated with Active DPM 1"
    }
    assert(colorsWithDpms.any { it.dpms?.contains(activeDpm2) == true }) {
      "One of the colors should be associated with Active DPM 2"
    }
    assert(colorsWithDpms.any { it.dpms?.contains(inactiveDpm1) == false }) {
      "None of the colors should be associated with Inactive DPM 1"
    }
    assert(colorsWithDpms.any { it.dpms?.contains(inactiveDpm2) == false }) {
      "None of the colors should be associated with Inactive DPM 2"
    }
  }

  @Test
  @Transactional
  fun `should see autogenerated dpms in the database`() {
    val adminRole = roleRepository.save(Role().apply { roleName = RoleName.ADMIN })

    val adminUser =
        User().apply {
          username = "admin@user.com"
          firstname = "Admin"
          lastname = "User"
          fullTime = true
          password = "<PASSWORD>"
          role = adminRole
        }
    userRepository.save(adminUser)

    val driver =
        User().apply {
          username = "driver@test.com"
          firstname = "Test"
          lastname = "Driver"
          points = 0
          fullTime = true
          password = "<PASSWORD>"
          manager = adminUser
        }
    userRepository.save(driver)

    val dpmGroup = createGroup("Test Group")

    val activeColor1 = createColor("Active Color 1", "1")
    val activeColor2 = createColor("Active Color 2", "2")
    val dpmEntity1 = createDpm("Test DPM 1", dpmGroup, activeColor1)
    val dpmEntity2 = createDpm("Test DPM 2", dpmGroup, activeColor2)

    `when`(authService.getCurrentUser()).thenReturn(adminUser)
    // Create some mock shifts that getAssignedShifts would return
    val mockShift1 = createShift(activeColor1.colorCode, driver.firstname!!, driver.lastname!!)
    val mockShift2 = createShift(activeColor2.colorCode, driver.firstname!!, driver.lastname!!)
    val mockShift3UntrackedColor =
        createShift(
            "0",
            driver.firstname!!,
            driver.lastname!!) // Will be filtered by `it.colorId in dpmColorMap`
    val mockShift4NotPublished =
        createShift(activeColor1.colorCode, driver.firstname!!, driver.lastname!!)
            .copy(published = "N") // will be filtered by published status
    val mockShift5NoBracket =
        createShift(activeColor1.colorCode, driver.firstname!!, driver.lastname!!)
            .copy(block = "EB") // will be filtered by block

    val mockShifts =
        listOf(
            mockShift1,
            mockShift2,
            mockShift3UntrackedColor,
            mockShift4NotPublished,
            mockShift5NoBracket)
    doReturn(mockShifts).`when`(autogenService).getAssignedShifts()

    entityManager.flush()
    entityManager.clear()
    autogenService.autoSubmit()

    entityManager.flush()
    entityManager.clear()

    val userDpms = userDpmRepository.findAll()
    assert(userDpms.size == 2) { "There should be 2 dpms in the database. Found ${userDpms.size}" }
    val createdDpmTypes = userDpms.mapNotNull { it.dpmType }

    assert(createdDpmTypes.any { it.id == dpmEntity1.id }) {
      "UserDPM list should contain one for DPM ${dpmEntity1.dpmName}"
    }
    assert(createdDpmTypes.any { it.id == dpmEntity2.id }) {
      "UserDPM list should contain one for DPM ${dpmEntity2.dpmName}"
    }

    val actualDpm1Points = userDpms.find { it.dpmType == dpmEntity1 }?.points ?: Integer.MIN_VALUE
    assert(actualDpm1Points == dpmEntity1.points) {
      "Test DPM 1 should have the same points as the original DPM. Expected: ${dpmEntity1.points}, Actual: $actualDpm1Points"
    }

    val actualDpm2Points = userDpms.find { it.dpmType == dpmEntity2 }?.points ?: Integer.MIN_VALUE
    assert(actualDpm2Points == dpmEntity2.points) {
      "Test DPM 2 should have the same points as the original DPM. Expected: ${dpmEntity2.points}, Actual: $actualDpm2Points"
    }
  }

  @Transactional
  fun createDpm(name: String, group: DpmGroup, color: W2WColor? = null): Dpm {
    return dpmRepository.saveAndFlush(
        Dpm().apply {
          this.dpmName = name
          this.points = (-10..10).random()
          this.dpmGroup = group
          this.w2wColor = color
        })
  }

  @Transactional
  fun createColor(name: String, code: String, active: Boolean = true): W2WColor {
    return w2wColorRepository.saveAndFlush(
        W2WColor().apply {
          this.colorName = name
          this.colorCode = code
          this.active = active
          this.hexCode = "#000000"
        })
  }

  private fun createShift(
      colorId: String,
      firstName: String,
      lastName: String,
      description: String = ""
  ): Shift {
    return Shift(
        published = "Y",
        firstName = firstName,
        lastName = lastName,
        startDate = "5/24/2025",
        endDate = "5/24/2025",
        startTime = "10:00am",
        endTime = "12:00pm",
        description = description,
        colorId = colorId,
        block = "[EB]")
  }
}
